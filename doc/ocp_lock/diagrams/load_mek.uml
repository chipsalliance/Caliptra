'
' OCP Lock: LOAD_MEK API sequence diagram showing Caliptra FW/HW interactions
'
'
@startuml

!include ocp_lock_utils.inc

!$show_all = %true()

!if ($show_all)
    !$show_precond = %true()
    !$show_title = %true()
    !$show_api = %true()
    !$show_msg_parsing = %true()
    !$show_done = %true()
!else
    !$show_precond = %false()
    !$show_title = %false()
    !$show_api = %false()
    !$show_msg_parsing = %false()
    !$show_done = %false()
!endif

!if ($show_title)
    Title "Load MEK"
!endif

!if ($show_precond)
    note across
        <b>Preconditions:</b>
        * The following sequence may or may not have occurred prior: Zero or more MIX_PMEK commands

        <b>Notes:</b>
          * The sequence diagram assumes that the KV will not allow an input KV slot to also be used as an out KV slot. Calitra FW is responsible for managing which KVC slots are used and can adapt if this assumption is not correct.
          * This sequence is focused on successful execution of operations by the KV. Sill need to do:
                 - <font color=red>Define the reported error conditions and handling
    end note
!endif


srk++ $BUFFER_ACTIVATION
sfr++

fw $async mb++ : LOAD_MEK

!if ($show_api)
    note right mb
        | <b>Field     | <b>Size | <b>Definition |
        | chksum       | u32     | Little endian |
        | metadata     | u8[20]  | Metadata for MEK to load into the drive crypto engine (i.e. NSID + LBA range) |
        | aux_metadata | u8[32]  | Auxiliary metadata for the MEK (optional; i.e. operation mode) |
        | rdy_timeout  | u32     | Timeout in ms for encryption engine to become ready for a new command |
        | cmd_timeout  | u32     | Timeout in ms for command to crypto engine to complete |
        | dek          | u8[32]  | Controller-supplied "data encryption key"\n    * May be a C_PIN-derived secret in Opal or a per-MEK value in KPIO |
    end note
!endif

mb $async cfw++ : Command

!if ($show_msg_parsing)
    cfw $sync mb : Get command
    mb--
    $self("cfw", "Determine command")
!else
    mb--
!endif

$self("cfw", "Use KV Slot X for deriving MEK")


alt Storage Root Key exists and Encryption Engin has become ready

    alt MEK is not initialized (i.e., no PMEK in the final MEK)
        cfw $sync kv++: HMAC512(Key: Slot A,\n                Key Data: "MEK Seed",\n                Destination: Slot X)
        kv $sync srk: Get Storage Root Key
        kv $sync kv: HMAC512 slot A with Data
        kv $sync meks: HMAC512 result MEK Seed with Storage Root Key
        meks++ $BUFFER_ACTIVATION
        !if ($show_done)
            kv $sync cfw-- : done
        !else
            kv--
        !endif
    end

    cfw $sync kv++: HMAC512(Key : Slox X,\n                Data String: "DEK" || dek,\n                Destination : Slot Y)
    kv $sync meks: Get MEK Seed
    kv $sync kv: HMAC512 Data Key String with Key
    kv $sync tempy: HMAC512 result MEK
    tempy++ $BUFFER_ACTIVATION
    !if ($show_done)
        kv $sync cfw-- : done
    !else
        kv--
    !endif


    cfw $sync sfr : Read Control Reg

    alt (DN == 1b || ERR == 1b || EXE == 1b)
        cfw $sync sfr : Write Control Reg (DN = 1b)

        cfw $sync cfw : Start timeout
        cfw $sync sfr : Read Control Reg
        group loop until (rdy_timeout or (DN == 0b && ERR == 0b && EXE == 0b)

            cfw $sync sfr : Read Control Reg
        end
    end

    group in any order
        cfw $async dma++ : MEK Write (Slot: Y)
        dma $sync tempy : Read MEK
        dma $sync sfr : Write MEK
        note left sfr
            If Encryption Engine uses a MEK which is smaller then MEK
            than the Encryption Engine truncates the MEK
        end note
        dma $async cfw-- : complete

        cfw $sync sfr : Write Aux
        cfw $sync sfr : Write Metadata
    end

    cfw $sync sfr : Write Control Reg (CMD = Load_MEK, DN = 0, EXE = 1)

    cfw $sync cfw : Start timeout

    cfw $sync sfr : Read Control Reg

    group loop until (cmd_timeout or DN = 1b)
        ee $sync sfr-- : Write Control Reg\n(DN = 1b,\n ERR = 0b,\n EXE = 0b)
        cfw $sync sfr : Read Control Reg
    end
    sfr--

    cfw $sync sfr : Write Control Reg (DN = 1b)
    note right: Reset the SFR interface for next operation - not waiting for response

    $self("cfw", "Mark that the sequence\nof an Initialize MEK then\nzero or more MIX_PMEK sequence\n is completed")
end

cfw $sync kv++: Purge_key(Key: Slot X,\n                Key : Slot Y)
kv $sync meks !! : Purge
& kv $sync tempy !!
!if ($show_done)
    kv $sync cfw-- : done
!else
    kv--
!endif

cfw $async mb : Command\nresponse\n(Status = Control Reg\n               Error field)
& mb $async fw++ : Command\ncomplete
cfw--

!if ($show_api)
    note right mb
        | <b>Field    | <b>Size | <b>Definition |
        | chksum      | u32     | Little endian |
        | fips_status | u32     | Indicates if the command is FIPS approved or an error |
    end note
!endif

@enduml
