---
title: "OCP L.O.C.K."
version: 0.8.1
type: BASE
project: NVMe^TM^
authors: [(See Acknowledgements section)]
contributor_cla_signers: [Google, Microsoft, Samsung, Kioxia, Solidigm]
acknowledgements: [
  Andrés Lagar-Cavilla (Google),
  Amber Huffman (Google)
  Charles Kunzman (Google),
  Chris Sabol (Google),
  Jeff Andersen (Google),
  Srini Narayanamurthy (Google),
  Anjana Parthasarathy (Microsoft),
  Ben Keen (Microsoft),
  Bharat Pillilli (Microsoft),
  Bryan Kelly (Microsoft),
  Christopher Swenson (Microsoft),
  Eric Eilertson (Microsoft),
  Lee Prewitt (Microsoft),
  Michael Norris (Microsoft),
  Eric Hibbard (Samsung),
  Gwangbae Choi (Samsung),
  Jisoo Kim (Samsung),
  Michael Allison (Samsung),
  Festus Hategekimana (Solidigm),
  Gamil Cain (Solidigm),
  Scott Shadley (Solidigm),
  Fred Knight (Kioxia),
  James Borden (Kioxia),
  John Geldman (Kioxia),
  Paul Suhler (Kioxia),
]
bibliography: bibliography.yaml
...
---

\currenttemplateversion

---

\tableofcontents

\listoffigures

\listoftables

---

\openwebfoundationzeropointninelicense

<!---
THE UPDATED DEFAULT CONTRIBUTOR LICENSE AGREEMENT (CLA) IS [OWFa 0.9](https://146a55aca6f00848c565-a7635525d40ac1c70300198708936b4e.ssl.cf1.rackcdn.com/images/ed0befaf86bee2568ad720ff4a9a554d1f4260f7.pdf).
PLEASE VERIFY THE CORRECT CLA/FSA IS USED AND EXECUTED FOR THIS CONTRIBUTION.
-->

\acknowledgements

# Compliance with OCP Tenets

<!---
Please describe how this Specification complies with the OCP tenets.
A full explanation of the OCP core tenets can be seen [here](https://146a55aca6f00848c565-a7635525d40ac1c70300198708936b4e.ssl.cf1.rackcdn.com/images/bf648bb75091907147e76846cad590f402660d2e.pdf).
-->

## Openness

OCP L.O.C.K. source for RTL and firmware will be licensed using the Apache 2.0 license. The specific mechanics and hosting of the code are work in progress due to CHIPS alliance timelines. Future versions of this spec will point to the relevant resources.

## Efficiency

OCP L.O.C.K. is used to generate and load keys for use of encrypting user data prior to storing data at rest and decrypting stored user data at rest when read. So, it cannot yield a measurable impact on system efficiency.

## Impact

OCP L.O.C.K. enables consistency and transparency to a foundational area of security of media encryption keys such that no drive firmware in the device ever has access to a media encryption key. Furthermore, no decrypted media encryption key exists in the device when power is removed from the device.

## Scale

OCP L.O.C.K. is a committed intercept for storage products for Google and Microsoft. This scale covers both a significant portion of the hyperscale and enterprise markets.

## Sustainability

The goal of OCP L.O.C.K. is to eliminate the need for cloud service providers (CSPs) to destroy storage devices (e.g., SSDs) by providing a mechanism that increases the confidence that a media encryption key within the device is deleted during cryptographic erase. This enables repurposing the device and or components on the device at end of use or end of life. Given the size of the market serving CSPs, this provides a significant reduction of e-waste.

# Base specification

## Introduction

OCP L.O.C.K. (Layered Open-source Cryptographic Key management) is a feature set conditionally compiled into Caliptra Subsystem 2.1+, which provides secure key management for Data-At-Rest protection in self-encrypting storage devices.

OCP L.O.C.K. was originally created as part of the Open Compute Project (OCP). The major revisions of the OCP L.O.C.K. specifications are published as part of Caliptra at OCP, as OCP L.O.C.K. is an extension to Caliptra. The evolving source code and documentation for Caliptra are in the repository within the CHIPS Alliance Project, a Series of LF Projects, LLC.

OCP L.O.C.K. may be integrated within a variety of self-encrypting storage devices, and is not restricted exclusively to NVMe^TM^.

## Background

In the life of a storage device in a datacenter, the device leaves the supplier, a customer writes user data to the device, and then the device is decommissioned. Customer data is not allowed to leave the data center. The CSP needs high confidence that the storage device leaving the datacenter is secure. The current default CSP policy to ensure this level of security is to destroy the drive. Other policies may exist that leverage drive capabilities (e.g., cryptographic erase), but are not generally deemed inherently trustworthy by these CSPs [@{self-encrypting-deception}]. This produces significant e-waste and inhibits any re-use/recycling.

Self-encrypting drives (SEDs) store data encrypted at rest to media encryption keys (MEKs). SEDs include the following building blocks:

- The storage media that holds data at rest.
- An encryption engine which performs line-rate encryption and decryption of data as it enters and exits the drive.
- A drive controller which exposes host-side APIs for managing the lifecycle of MEKs.

MEKs may be bound to user credentials, which the host must provide to the drive in order for the associated data to be readable. A given MEK may be bound to one or more credentials. This model is captured in the TCG Opal [@{tcg-opal}] specification.

MEKs may be erased, to cryptographically erase all data which was encrypted to the MEK. To erase an MEK, it is sufficient for the drive to erase all copies of it, or all copies of a key with which it was protected.

## Threat model

The protected asset is the user data stored at rest on the drive. The adversary profile extends up to nation-states in terms of capabilities.

Adversary capabilities include:

- Interception of a storage device in the supply chain.
- Theft of a storage device from a data center.
- Destructively inspecting a stolen device.
- Running arbitrary firmware on a stolen device.
  - This includes attacks where vendor firmware signing keys have been compromised.
- Attempting to glitch execution of code running on general-purpose cores.
- Stealing debug core dumps or UART/serial logs from a device while it is operating in a data center, and later stealing the device.
- Gaining access to any class secrets, global secrets, or symmetric secrets shared between the device and an external entity.
- Executing code within a virtual machine on a multi-tenant host offered by the CSP which manages an attached storage device.
- Accessing all device design documents, code, and RTL.

Given this adversary profile, the following are a list of vulnerabilities that OCP L.O.C.K. is designed to mitigate.

- MEKs managed by storage drive firmware are compromised due to implementation bugs or side channels.
- MEKs erased by storage drive firmware are recoverable via invasive techniques.
- MEKs are not fully bound to user credentials due to implementation bugs.
- MEKs are bound to user credentials which are compromised by a vulnerable host.
- Cryptographic erase was not performed properly due to a buggy host.

## OCP L.O.C.K. goals

OCP L.O.C.K. is being defined to improve drive security. In an SED that takes Caliptra with OCP L.O.C.K. features enabled, Caliptra will act as a Key Management Block (KMB). The KMB will be the only entity that can read MEKs and program them into the SED's encryption engine. The KMB will expose services to drive firmware which will allow the drive to transparently manage each MEK's lifecycle, without being able to access the raw MEK itself.

The OCP L.O.C.K. KMB satisfies the following properties:

- Prevents leakage of media keys via firmware vulnerabilities or side channels, by isolating MEKs to a trusted component.
- Binds MEKs to a given set of externally-supplied access keys, provisioned with replay-resistant transport security such that they can be injected without trusting the host.
- Uses epoch keys for attestable epoch-based cryptographic erase.
- Is able to be used in conjunction with the Opal or Key Per I/O [@{tcg-kpio}] storage device specifications.

Note that Opal in the context of this document includes the Opal Family of SSCs: Opal SSC, Opalite SSC, Ruby SSC. Pyrite is excluded as Pyrite SSDs are non-SED.

### Non-goals

The following areas are out of scope for this project.

- Compliance with IEEE 1619^TM^-2025 [@{ieee-1619-2025}] requirements around key scope, i.e. restricting a given MEK to only encrypt a maximum of 2^44^ 128-bit blocks. Drive firmware will be responsible for enforcing this.
- Compliance with FIPS 140-3 IG [@{fips-140-3-ig}] section C.I requirements around inequality testing for AES-XTS component keys. The encryption engine will be responsible for enforcing this.
- Compliance with Common Criteria requirement FCS_CKM.1.1(c) [@{cpp-fde}] when supporting derived MEKs. Key Per I/O calls for DEKs to be injected into the device. To support OCP L.O.C.K.'s goals around enabling cryptographic erase, before the injected DEK is used to encrypt user data, the DEK is first conditioned with an on-device secret that can be securely zeroized. FCS_CKM.1.1(c) currently does not allow injected keys to be thus conditioned and therefore does not allow for cryptographic erase under the Key Per I/O model. A storage device that integates OCP L.O.C.K. and aims to be compliant with this Common Criteria requirement may not support Key Per I/O.
- Authorization for EPK/DPK/MPK rotation, or binding a given MEK to a particular locking range. The drive firmware is responsible for these.

### Integration verification

A product which integrates OCP L.O.C.K. will be expected to undergo an OCP S.A.F.E. review, to ensure that the drive firmware correctly invokes OCP L.O.C.K. services.

---

## Architecture

![OCP L.O.C.K. high level blocks](./diagrams/architecture_diagram.drawio.svg){#fig:architecture-diagram}

To safeguard user data stored on the drive, KMB defines a set of "protection keys", each of which must be available in order for an MEK to be accessible.

- The **data protection key (DPK)**, which is managed by the nominal owner of the data. A given MEK is bound to a single DPK.
  - In Opal the DPK may be protected by the user's C_PIN, while in Key Per I/O the DPK may be the DEK associated with a given key tag.

- A configurable number of **Multi-party Protection Keys (MPKs)**, which are each managed by an additional entity that must assent before user data is available. A given MEK may be bound to zero or more MPKs.
  - Each multi-party entity grants access to the data by providing an access key to the drive. Each MPK is protected by a distinct access key, which is never stored persistently within the drive. MPK access keys are protected in transit using HPKE [@{ietf-rfc9180}]. This enables use-cases where the access key is served to the drive from a remote key management service, without revealing the access key to the drive's host.
  - Binding an MEK to zero MPKs allows for legacy Opal or Key Per I/O support.

- A composite **epoch protection key (EPK)**, which is a concatenation of two "component epoch keys" held within the device: the **Soft Epoch Key (SEK)** and the **Hard Epoch Key (HEK)**. The EPK is managed by the storage device itself, and all MEKs in use by the device are bound to it.
  - All MEKs in use by the drive can be cryptographically erased by zeroizing either the SEK or HEK. New MEKs shall not be loadable until the zeroized epoch keys are regenerated.
  - KMB reports the zeroization state of the SEK and HEK, and therefore whether the drive is in a cryptographically erased state.
  - The SEK is managed by drive firmware and shall be held in rewritable storage, e.g. in flash memory.
  - The HEK is managed by KMB and shall be held in fuses. This provides assurance that an advanced adversary is unable to recover key material that had been in use by the drive prior to the HEK zeroization.

The EPK, DPK, and set of configured MPKs are used together to derive an MEK secret, which protects a given MEK. The MEK protection is implemented as one of two methods:

- **MEK encryption** - the drive obtains a random MEK from KMB, encrypted by the MEK secret, and is allowed to load that encrypted MEK into the encryption engine via KMB. This supports Opal use-cases.

- **MEK derivation** - the drive instructs KMB to derive an MEK from the MEK secret and load the MEK into the encryption engine. This may support either Opal or Key Per I/O use-cases.

MEKs are never visible to drive firmware. Drive firmware instructs KMB to load MEKs into the key cache of the encryption engine, using standard interfaces described in @sec:interfaces. Each MEK has associated vendor-defined metadata, e.g. to identify the namespace and LBA range to be encrypted by the MEK.

KMB shall not cache MEKs in memory. The encryption engine shall remove all MEKs from the encryption engine on a power cycle or upon request from drive firmware.

All keys randomly generated by KMB are generated using a DRBG seeded by Caliptra's TRNG. The DRBG may be updated using entropy provided by the host.

### Host APIs

The DPK can be modeled using existing TCG Opal or Key Per I/O host APIs.

Rotation of the HEK and SEK, management of MPKs and MPK access keys, and injection of host entropy, require additional host APIs beyond those available in TCG Opal or Key Per I/O. Such APIs are beyond the scope of the present document.

### Key hierarchy

![OCP L.O.C.K. key hierarchy](./diagrams/key_hierarchy.drawio.svg){#fig:key-hierarchy}

#### Preconditioned HKDF

In this specification, several flows involve combining together multiple symmetric keys. These keys have different scopes and lifespans. For example, the HEK and SEK are long-lived per-drive keys, while the DPK is unique to each MEK.

NIST SP 800-133 [@{sp800-133r2}] section 6.3 provides a number of FIPS-approved methods for combining keys together. This specification leverages HKDF-Extract [@{ietf-rfc5869}], which is equivalent to the key-extraction process detailed in SP 800-133 section 6.3. That section provides the following stipulation: "Each component key **shall** be kept secret and **shall not** be used for any purpose other than the computation of a specific symmetric key K (i.e., a given component key **shall not** be used to generate more than one key)."

A strict reading of this requirement would preclude, for example, combining the same SEK with different DPKs to produce different per-MEK output keys. Therefore, this specification defines the "preconditioned HKDF-Extract" operation, illustrated in @fig:preconditioned-hkdf.

![Preconditioned HKDF-Extract](./diagrams/preconditioned_hkdf.drawio.svg){#fig:preconditioned-hkdf}

Each input key is preconditioned using a unique identifier composed from each of the constituent keys, before being combined using HKDF-Extract. Therefore each key fed to HKDF-Extract is unique to the given key mixing operation and will not be re-used to produce different output keys.

Subsequent diagrams will use this operation when combining keys with different scopes or lifetimes.

### MPKs {#sec:mpks}

MPKs are the mechanism by which KMB enforces multi-party authorization as a precondition to loading an MEK. MPKs exist in one of two states: locked or ready. In both these states the MPK is encrypted to a key known only to KMB.

- A locked MPK's encryption key is derived from the HEK as well as an externally-supplied access key to which the MPK is bound. The locked MPK is held at rest by drive firmware.
- The Ready MPK Encryption Key is a volatile key held within KMB which is lazily generated and is lost when the drive shuts down. Lazy generation allows injected host entropy to contribute to the key's generation. Ready MPKs are held in drive firmware memory.

The externally-supplied access key is encrypted in transit using an HPKE public key held by KMB. The "ready" state allows the HPKE keypair to be rotated after the access key has been provisioned to the storage device, without removing the ability for KMB to decrypt the MPK when later loading an MEK bound to that MPK.

For each MPK to which a given MEK is bound, the host is expected to invoke a command to supply the MPK's encrypted access key. Upon receipt the drive firmware passes that encrypted access key to KMB, along with the locked MPK, to produce the ready MPK which is cached in drive memory. This is done prior to the drive firmware actually loading the MEK, and is performed once for each MPK to which a given MEK is bound.

#### Transport encryption for MPK access keys

KMB maintains a set of HPKE keypairs, one per HPKE algorithm that KMB supports. Each HPKE public key is endorsed with a certificate that is generated by KMB and signed by Caliptra's DICE [@{tcg-dice}] identity. HPKE keypairs are randomly generated on KMB startup, and mapped to unique handles. Keypairs may be periodically rotated and are lost when the drive resets. Drive firmware is responsible for enumerating the available HPKE public keys and exposing them to the user via a host interface. The nature of the host interface is outside the scope of this specification.

When a user wishes to generate or ready an MPK (which is required prior to loading any MEKs bound to that MPK), the user performs the following steps:

1. Select the HPKE public key and obtain its certificate from the storage device.
2. Validate the HPKE certificate and attached DICE certificate chain.
3. Decode the HPKE capabilities of the storage device based on the HPKE certificate.
4. Seal their access key using the HPKE public key.
5. Transmit the sealed access key to the storage device.

Upon receipt, KMB will unwrap the access key and proceed to generate or ready the MPK.

Upon drive reset, the HPKE keypairs are regenerated, and any access keys for MPKs that had been made ready prior to the reset will need to be re-provisioned in order to transition those MPKs to a ready state again.

##### Algorithm support

KMB supports the following HPKE algorithms:

- P-384 ECDH
- Hybridized ML-KEM-1024 with P-384 ECDH

@fig:hpke-unwrap-ecdh and @fig:hpke-unwrap-hybrid illustrate the detailed cryptographic operations involved in unwrapping the access key using each of these algorithms. Subsequent diagrams elide these details and represent the operation as "HPKE unwrap".

![HPKE unwrap for MPK access keys with ECDH](./diagrams/mpk_access_key_ecdh_unwrap.drawio.svg){#fig:hpke-unwrap-ecdh}

![HPKE unwrap for MPK access keys with hybrid ML-KEM + ECDH](./diagrams/mpk_access_key_hybrid_unwrap.drawio.svg){#fig:hpke-unwrap-hybrid}

The only difference between @fig:hpke-unwrap-ecdh and @fig:hpke-unwrap-hybrid is how the shared secret is derived. Operations which produce an AES key and IV from that shared secret are identical, and are omitted from @fig:hpke-unwrap-hybrid for brevity.

#### MPK lifecycle

MPKs can be generated, made ready, and have their access keys rotated.

##### MPK generation

Drive firmware may request that KMB generate an MPK, bound to a given access key. KMB performs the following steps:

1. Unwrap the given MPK access key using the HPKE keypair held within KMB.
2. Randomly generate an MPK.
3. Derive an MPK encryption key from the HEK and the decrypted access key.
4. Encrypt the MPK to the MPK encryption key.
5. Return the encrypted MPK to the drive firmware.

Drive firmware may then store the encrypted MPK in persistent storage.

To mitigate against cryptographic attacks on the HPKE keypair that rely on repeated invocations of this command, this command is rate-limited.

![MPK generation](./diagrams/mpk_generate.drawio.svg){#fig:mpk-generation}

##### MPK readying

Encrypted MPKs stored at rest in persistent storage are considered "locked", and must be made ready before they can be used to load an MEK. Ready MPKs are also encrypted when handled by drive firmware, to the Ready MPK Encryption Key. Ready MPKs do not survive across device reset.

To ready an MPK, KMB performs the following steps:

1. Unwrap the given MPK access key using the HPKE keypair held within KMB.
2. Derive the MPK encryption key from the HEK and the decrypted access key.
3. Decrypt the MPK using the MPK encryption key.
4. Encrypt the MPK using the Ready MPK Encryption Key.
5. Return the re-encrypted "ready" MPK to the drive firmware.

Drive firmware may then stash the encrypted ready MPK in volatile storage, and later provide it to the KMB when loading an MEK, as described in @sec:meks.

To mitigate against cryptographic attacks on the HPKE keypair that rely on repeated invocations of this command, this command is rate-limited.

![MPK readying](./diagrams/mpk_ready.drawio.svg){#fig:mpk-readying}

##### MPK access key rotation

The access key to which an MPK is bound may be rotated. The user must prove that they have knowledge of both the old and new access key before a rotation is allowed. This is accomplished using a slight variation on the usual access key import flow. When a new access key is provided to KMB during a rotation, the new access key is double-encrypted: first to the old access key, and then to the HPKE public key. KMB performs the following steps:

1. Unwrap the given old access key and encrypted new access key using the HPKE keypair held within KMB.
2. Decrypt the new access key using the old access key.
3. Derive the old MPK encryption key from the HEK and the decrypted old access key.
4. Derive the new MPK encryption key from the HEK and the decrypted new access key.
5. Decrypt the MPK using the old MPK encryption key.
6. Encrypt the MPK using the new MPK encryption key.
7. Return the re-encrypted MPK to the drive firmware.

Drive firmware then purges the old encrypted MPK and stores the new encrypted MPK in persistent storage.

To mitigate against cryptographic attacks on the HPKE keypair that rely on repeated invocations of this command, this command is rate-limited.

![MPK access key rotation](./diagrams/mpk_access_key_rotation.drawio.svg){#fig:mpk-access-key-rotation}

### DPKs

Drive firmware provides the DPK (Data Protection Key) to KMB when generating, loading, or deriving an MEK. The DPK is used in a KDF, along with the HEK, SEK, and MPKs, to derive the MEK secret, as illustrated in @sec:meks.

#### Use when generating or loading an MEK

In this flow, the DPK may be encrypted by a user's Opal C_PIN. Drive firmware logic which decrypts MEKs can be repurposed to produce the DPK.

![Example drive flow to decrypt a DPK based on a host-provided Opal C_PIN](./diagrams/dpk_decryption.drawio.svg){#fig:dpk-decryption}

#### Use when deriving an MEK

In this flow, the DPK may be the imported key associated with a Key Per I/O key tag.

![Example drive flow to accept an injected DPK](./diagrams/dpk_injection.drawio.svg){#fig:dpk-injection}

### HEKs and SEKs

KMB supports a pair of epoch keys: the HEK and SEK. Both must be available, i.e. non-zeroized, in order for MEKs to be loaded.

- The **HEK** is derived from secrets held in Caliptra's fuse block, and is never visible outside of Caliptra. If the HEK is zeroized, KMB does not allow MEKs to be loaded.
- The **SEK** is managed by drive firmware, and may be stored in flash. If the SEK is zeroized, drive firmware is responsible for enforcing that MEKs are not loaded.

Zeroizing either the HEK or SEK is equivalent to performing a cryptographic erase. HEK zeroization is effectively a "hard" cryptographic erase, as it is highly difficult to recover secrets from a zeroized fuse bank.

#### HEK derivation inputs

##### Stable Identity Key

Caliptra features a [Stable Identity](https://github.com/chipsalliance/caliptra-sw/blob/main-2.x/rom/dev/README.md#derivation-of-the-key-ladder-for-stable-identity) Key (SIK), which is a secret derived from Caliptra's LDevID CDI as well as the current lifecycle and debug states. The SIK can be used to protect long-lived data. Caliptra's Stable Identity feature is implemented in terms of a key ladder, with different keys for different Caliptra firmware Security Version Numbers (SVNs), with the property that Caliptra firmware whose SVN is X can only obtain Stable Identity keys bound to SVNs less than or equal to X. The SIK used by KMB is the key ladder secret bound to SVN 0, ensuring that Caliptra firmware of any SVN can wield it.

##### Ratchet secrets

Caliptra with L.O.C.K. features a series of n 256-bit ratchet secrets present in a fuse bank, dubbed R~0~..R~n-1~, where 4 ≤ n ≤ 16. The vendor is responsible for determining the number of ratchet secrets available in fuses. These ratchet secrets are only programmable and readable by Caliptra Core, via the Caliptra fuse controller. KMB transitions each ratchet secret individually from blank → randomized → zeroized. R~x~ is only randomized once R~x-1~ has been zeroized. KMB zeroizes a ratchet secret by blowing every bit.

#### HEK derivation

@tbl:hek-lifecycle-states describes the states between which the HEK transitions over the lifespan of the device.

Table: HEK lifecycle states {#tbl:hek-lifecycle-states}

+--------------------------------+-------------------------+-------------------+---------------------------------------------------+
| Caliptra lifecycle state       | Ratchet secret state    | Derivation inputs | Description                                       |
+================================+=========================+===================+===================================================+
| Unprovisioned or manufacturing | [Any]                   | SIK               | HEK is available for pre-production testing.      |
+--------------------------------+-------------------------+-------------------+---------------------------------------------------+
| Production                     | No ratchet secret is    | N/A               | HEK is unavailable.                               |
|                                | randomized.             |                   |                                                   |
+--------------------------------+-------------------------+-------------------+---------------------------------------------------+
| Production                     | R~x~ is randomized.     | SIK and R~x~      | HEK is available and can be disabled by zeroizing |
|                                |                         |                   | R~x~.                                             |
+--------------------------------+-------------------------+-------------------+---------------------------------------------------+
| Production                     | Every ratchet secret is | SIK               | HEK is permanently available. Owners may opt into |
|                                | zeroized.               |                   | this state once every ratchet secret has been     |
|                                |                         |                   | zeroized.                                         |
|                                |                         |                   |                                                   |
|                                |                         |                   | In this state, data written to the storage device |
|                                |                         |                   | can no longer be cryptographically erased via     |
|                                |                         |                   | ratchet secret zeroization.                       |
|                                |                         |                   |                                                   |
|                                |                         |                   | To satisfy FIPS 140-3 zeroization requirements    |
|                                |                         |                   | in this state, the FIPS boundary will need to     |
|                                |                         |                   | include SEK zeroization functionality in the      |
|                                |                         |                   | storage drive firmware.                           |
+--------------------------------+-------------------------+-------------------+---------------------------------------------------+

@tbl:hek-lifecycle-commands describes the commands that KMB exposes to manage the HEK lifecycle.

Table: HEK lifecycle management commands {#tbl:hek-lifecycle-commands}

+----------------------------------+------------------------------------------------------------------+
| Command                          | Description                                                      |
+==================================+==================================================================+
| [PROGRAM_NEXT_HEK                | Programs a random ratchet secret into the next slot. Upon        |
| ](#sec:program-next-hek-cmd)     | success, if the SEK is programmed, MEKs may be loaded.           |
+----------------------------------+------------------------------------------------------------------+
| [ZEROIZE_CURRENT_HEK             | Sets the current ratchet secret fuses to all-ones. May be        |
| ](#sec:zeroize-current-hek-cmd)  | re-attempted if an error caused the active ratchet secret to be  |
|                                  | left in an invalid state. Upon success, MEKs may not be loaded.  |
+----------------------------------+------------------------------------------------------------------+
| [ENABLE_PERMANENT_HEK            | Enables a mode where the HEK is derived solely from the SIK. May |
| ](#sec:enable-permanent-hek-cmd) | only be invoked once all ratchet secrets are zeroized. May be    |
|                                  | re-attempted if an error caused the permanent-HEK fuse indicator |
|                                  | to be left in an invalid state. Upon success, if the SEK is      |
|                                  | programmed, MEKs may be loaded.                                  |
+----------------------------------+------------------------------------------------------------------+

If an error causes the active ratchet secret to be left in an invalid state, MEKs may not be loaded. If this state persists, the device is unusable.

A device out of manufacturing must be in production mode with a ratchet secret programmed.

@fig:hek-derivation illustrates HEK derivation, for the states where the HEK is available.

![HEK derivation](./diagrams/hek_derivation.drawio.svg){#fig:hek-derivation}

#### HEK and SEK lifecycle

@fig:hek-sek-rotation illustrates the case where a drive ships with four ratchet secrets.

![HEK and SEK state machine](./diagrams/hek_sek_rotation.drawio.svg){#fig:hek-sek-rotation}

Drive firmware is responsible for enforcing that SEK programming and zeroization follows the state machine illustrated in @fig:hek-sek-rotation. Specifically:

- The SEK shall only be programmed once the HEK is available.
- The HEK shall only be zeroized once the SEK is zeroized.

### MEKs {#sec:meks}

KMB can encrypt randomly-generated MEKs, or compute derived MEKs.

@fig:mek-secret-derivation provides details on how the SEK, HEK, DPK, and MPKs are used to produce the MEK secret, which then either encrypts/decrypts a random MEK or is used to compute a derived MEK.

![MEK secret derivation](./diagrams/mek_secret_derivation.drawio.svg){#fig:mek-secret-derivation}

Note: it is the drive firmware's responsibility to ensure that MPKs are mixed in the correct order for a given MEK.

#### Generating and loading a random MEK

The figures in this section elide the process of deriving the MEK secret, as those details are captured in @fig:mek-secret-derivation. When an MEK is generated or loaded, the inputs given in @fig:mek-secret-derivation are provided by drive firmware so that KMB may derive the MEK secret.

![Generating an MEK](./diagrams/mek_generate.drawio.svg){#fig:mek-generate}

![Loading an MEK](./diagrams/mek_load.drawio.svg){#fig:mek-load}

### Random key generation via DRBG

KMB generates multiple kinds of random keys. It does so using randomness obtained from a DRBG, which is seeded from Caliptra's TRNG and which may be updated with entropy from the host.

![DRBG usage](./diagrams/drbg_diagram.drawio.svg){#fig:drbg-usage}

Note that Caliptra hardware only supports the \`DRBG_Update\` operation when Caliptra is instantiated with an internal TRNG [@{caliptra-2.0-hw-spec}].

### Boot-time initialization

At initial boot, Caliptra firmware performs the following steps:

- Determines whether a HEK is available, based on the fuse configuration. If a HEK is unavailable, KMB enters a mode where MEKs are not allowed to be loaded.
- Initializes random HPKE keypairs for each supported algorithm, and assigns handles to them, reported via [ENUMERATE_KEM_HANDLES](#sec:enumerate-kem-handles).

The Ready MPK encryption key is not initialized at boot-up, as it is generated lazily upon first use. See @sec:mpks for details.

---

## Interfaces {#sec:interfaces}

OCP L.O.C.K. defines two interfaces:

- The [encryption engine interface](#sec:encryption-engine-interface) is exposed from the vendor-implemented encryption engine to KMB, and defines a standard mechanism for programming MEKs and control messages.
- The [mailbox interface](#sec:mailbox-interface) is exposed from KMB to storage drive firmware, and enables the drive to manage MEKs and associated keys.

### Encryption engine interface {#sec:encryption-engine-interface}

This section defines the interface between KMB and an encryption engine. An encryption engine is used to encrypt/decrypt user data. Its design and implementation are vendor specific. MEKs are generated or derived within KMB and used by the encryption engine to encrypt and decrypt user data. The interface defined in this section is used to load MEKs from KMB to the encryption engine or to cause the encryption engine to unload (i.e., remove) loaded MEKs. MEKs shall not be accessible to the drive firmware as they are being transferred between KMB and the encryption engine.

#### Overview

The encryption engine uses an MEK stored in volatile memory to encrypt and decrypt user data. For the purposes of this specification, the entity within the encryption engine used to store the MEKs is called the key cache. Each encryption and decryption of user data is coupled to a specific MEK which is stored in the key cache bound to a unique identifier, called metadata. Each (metadata, MEK) pair is also associated with additional information, called aux, which is used neither as MEK nor an identifier, but has some additional information about the pair. Therefore, the key cache as an entity which stores (metadata, aux, MEK) tuples.

To ensure that MEKs are only ever visible to KMB and the encryption engine, KMB is the only entity which can load and unload (metadata, aux, MEK) tuples. Drive firmware arbitrates all operations in the KMB to encryption engine interface, and is therefore responsible for managing which MEK is loaded in the key cache. Drive firmware has full control on metadata and optional aux. @fig:encryption-engine is an illustration of the KMB → encryption engine interface which shows:

- The tuple for loading an MEK.
- The metadata for unloading an MEK.
- An example of a key cache configuration within the encryption engine.

![KMB to encryption engine SFR interface](./diagrams/kmb_ee.drawio.svg){#fig:encryption-engine}

The behavior of I/O through the encryption engine during the execution of an SFR command is vendor-defined.

#### Special Function Registers

KMB uses Special Function Registers (SFRs) to communicate with the encryption engine as shown in @tbl:kmb-ee-sfrs and each of the following subsections which describe the registers.

Table: KMB to encryption engine SFRs {#tbl:kmb-ee-sfrs}

+------------------+----------------+-----------+-------------------------+
| Register         | Address        | Byte Size | Description             |
+==================+================+===========+=========================+
| Control          | SFR_BASE + 0h  | 4h        | Register to handle      |
|                  |                |           | commands                |
+------------------+----------------+-----------+-------------------------+
| Metadata         | SFR_BASE + 10h | 14h       | Register to provide     |
| (METD)           |                |           | metadata                |
+------------------+----------------+-----------+-------------------------+
| Auxiliary Data   | SFR_BASE + 30h | 20h       | Register to provide     |
| (AUX)            |                |           | auxiliary values        |
+------------------+----------------+-----------+-------------------------+
| Media Encryption | SFR_BASE + 50h | 40h       | Register to provide MEK |
| Key (MEK)        |                |           |                         |
+------------------+----------------+-----------+-------------------------+

SFR_BASE is an address that is configured within KMB. The integrator should make sure that KMB can access these SFRs through these addresses.

##### Control register {#sec:control-register}

@tbl:ee-ctrl-sfr defines the Control register used to sequence the execution of a command and obtain the status of that command.

Table: Offset SFR_Base + 0h: CTRL – Control {#tbl:ee-ctrl-sfr}

+-------+------+-------+-----------------------------------------------------------+
| Bits  | Type | Reset | Description                                               |
+=======+======+=======+===========================================================+
| 31    | RO   | 0h    | **Ready (RDY):** After an NVM Subsystem Reset occurs, the |
|       |      |       | encryption engine sets this bit to 1b, indicating that    |
|       |      |       | the encryption engine is ready to execute commands. If    |
|       |      |       | this bit is 0b, then the encryption engine is not ready   |
|       |      |       | to execute commands.                                      |
+-------+------+-------+-----------------------------------------------------------+
| 30:20 | RO   | 0h    | Reserved                                                  |
+-------+------+-------+-----------------------------------------------------------+
| 19:16 | RO   | 0h    | **Error (ERR):** When the encryption engine sets the DONE |
|       |      |       | bit to 1b, the encryption engine sets this field to 0000b |
|       |      |       | if the command specified by the CMD field succeeded, or a |
|       |      |       | non-zero value if the command failed. See                 |
|       |      |       | @tbl:ee-ctrl-err-codes.                                   |
|       |      |       |                                                           |
|       |      |       | Encryption engine error codes are surfaced back to drive  |
|       |      |       | firmware. If the DONE bit is set to 1b by KMB, then this  |
|       |      |       | field is set to 0000b.                                    |
+-------+------+-------+-----------------------------------------------------------+
| 15:6  | RO   | 0h    | Reserved                                                  |
+-------+------+-------+-----------------------------------------------------------+
| 5:2   | RW   | 0h    | **Command (CMD):** This field specifies the command to    |
|       |      |       | execute or the command associated with the reported       |
|       |      |       | status. See @tbl:ee-ctrl-cmd-codes.                       |
+-------+------+-------+-----------------------------------------------------------+
| 1     | RW   | 0b    | **Done (DONE):** This bit indicates the completion of a   |
|       |      |       | command by the encryption engine. If this bit is set to   |
|       |      |       | 1b by the encryption engine, then the encryption engine   |
|       |      |       | has completed the command specified by the CMD field. If  |
|       |      |       | the EXE bit is 1b and this bit is 1b, then the encryption |
|       |      |       | engine has completed executing the command specified by   |
|       |      |       | the CMD field and the ERR field indicates the status of   |
|       |      |       | the execution of that command. A write by KMB of the      |
|       |      |       | value 1b to this bit shall cause the encryption engine    |
|       |      |       | to:                                                       |
|       |      |       |                                                           |
|       |      |       | - set this bit to 0b;                                     |
|       |      |       | - set the EXE bit to 0b; and                              |
|       |      |       | - set the ERR field to 0000b.                             |
|       |      |       |                                                           |
|       |      |       | When the encryption engine writes the value of 1b to the  |
|       |      |       | DONE field, the value of the EXE bit does not change.     |
+-------+------+-------+-----------------------------------------------------------+
| 0     | RW   | 0b    | **Execute (EXE):** A write by KMB of the value 1b to this |
|       |      |       | bit specifies that the encryption engine is to execute    |
|       |      |       | the command specified by the CMD field. If the DONE bit   |
|       |      |       | is set to 1 by KMB, then the encryption engine sets the   |
|       |      |       | EXE bit to 0b.                                            |
+-------+------+-------+-----------------------------------------------------------+

Table: CTRL error codes {#tbl:ee-ctrl-err-codes}

+----------+--------------------+
| Value    | Description        |
+==========+====================+
| 0h       | Command successful |
+----------+--------------------+
| 1h to 3h | Reserved           |
+----------+--------------------+
| 4h to Fh | Vendor Specific    |
+----------+--------------------+

Table: CTRL command codes {#tbl:ee-ctrl-cmd-codes}

+----------+-----------------------------------------------------------+
| Value    | Description                                               |
+==========+===========================================================+
| 0h       | Reserved                                                  |
+----------+-----------------------------------------------------------+
| 1h       | **Load MEK:** Load the key specified by the AUX field and |
|          | MEK register into the encryption engine as specified by   |
|          | the **METD** field.                                       |
+----------+-----------------------------------------------------------+
| 2h       | **Unload MEK:** Unload the MEK from the encryption engine |
|          | as specified by the **METD** field.                       |
+----------+-----------------------------------------------------------+
| 3h       | **Zeroize**: Unload all of the MEKs from the encryption   |
|          | engine (i.e., zeroize the encryption engine MEKs).        |
+----------+-----------------------------------------------------------+
| 4h to Fh | Reserved                                                  |
+----------+-----------------------------------------------------------+

From the KMB, the Control register is the register to write a command and receive its execution result. From its counterpart, the encryption engine, the Control register is used to receive a command and write its execution result.

The expected change flow of the Control register to handle a command is as follows:

1. If **RDY** is set to 1b, then KMB writes **CMD** and **EXE**
    1. **CMD:** either 1h, 2h or 3h
    2. **EXE:** 1b
2. The encryption engine writes **ERR** and **DONE**
    1. **ERR:** either 0b or a non-zero value depending on the execution result
    2. **DONE:** 1b
3. The KMB writes **DONE**
    1. **DONE:** 1b
4. The encryption engine writes **CMD**, **ERR**, **DONE** and **EXE**
    1. **CMD:** 0h
    2. **ERR:** 0h
    3. **DONE:** 0b
    4. **EXE:** 0b

The KMB therefore interacts with the Control register as follows in the normal circumstance:

1. The KMB writes **CMD** and **EXE**
    1. **CMD:** either 1h, 2h or 3h
    2. **EXE:** 1b
2. The KMB waits **DONE** to be 1
3. The KMB writes **DONE**
    1. **DONE:** 1b
4. The KMB waits **DONE** to be 0

Since the Control register is a part of the encryption engine whose implementation can be unique to each vendor, behaviors of the Control register with respect to unexpected flows are left for vendors. For example, a vendor who wants robustness might integrate a write-lock into the Control register in order to prevent two almost simultaneous writes on the EXE bit. Vendors shall ensure that any customizations remain compatible with the interface defined in this specification.

##### Metadata register

@tbl:ee-metd-sfr defines the Metadata register used to pass additional data related to the MEK.

Table: Offset SFR_Base + 10h: METD – Metadata {#tbl:ee-metd-sfr}

+-------+------+-------+--------------------------------------------------------------+
| Bytes | Type | Reset | Description                                                  |
+=======+======+=======+==============================================================+
| 19:00 | RW   | 0h    | **Metadata (METD):** This field specifies metadata that      |
|       |      |       | is vendor specific and specifies the entry in the encryption |
|       |      |       | engine for the MEK.                                          |
+-------+------+-------+--------------------------------------------------------------+

The KMB and the encryption engine must be the only components which have access to MEKs. Each MEK is associated with a unique identifier, which may be visible to other components, in order for the MEK to be used for any key-related operations including data I/O. The **METD** field is used as such an identifier.

Instead of generating a random and unique identifier within the KMB while loading an MEK, the KMB takes an **METD** value as input from the drive firmware and write to the **METD** register without any modification for the sake of the following reasons:

1. A vendor does not need to implement an additional algorithm to map between identifiers in its own system and in the KMB
2. A vendor-unique key-retrieval algorithm can easily be leveraged into a **METD**-generation algorithm

In order to reduce ambiguity, two examples of the **METD** field will be given: Logical Block Addressing (LBA) range-based metadata; and key-tag based metadata.

When an SSD stores data with address-based encryption, an MEK can be uniquely identified by a (LBA range, Namespace ID) pair. Then, the (LBA range, Namespace ID) pair can be leveraged into **METD** as on @fig:lba-nsid-layout.

![LBA range based metadata format](./diagrams/metadata_register_lba_nsid.drawio.svg){#fig:lba-nsid-layout}

Address-based encryption is not the only encryption mechanism in SSDs. For example, in TCG Key Per I/O, an MEK is selected by a key tag, which does not map to an address. @fig:key-tag-layout shows an example of **METD** in such cases.

![Key tag based metadata format](./diagrams/metadata_register_key_tag.drawio.svg){#fig:key-tag-layout}

The above examples are not the only possible values of **METD**. Vendors are encouraged to design and use their own **METD** if it fits better to their system.

##### Auxiliary Data register

@tbl:ee-aux-sfr defines the Auxiliary Data register used to pass additional vendor-specific data related to the MEK.

Table: Offset SFR_Base + 20h: AUX – Auxiliary Data {#tbl:ee-aux-sfr}

+-------+------+-------+----------------------------------------------------------+
| Bytes | Type | Reset | Description                                              |
+=======+======+=======+==========================================================+
| 31:00 | RW   | 0h    | **Auxiliary Data (AUX):** This field specifies auxiliary |
|       |      |       | data associated to the MEK.                              |
+-------+------+-------+----------------------------------------------------------+

The **AUX** field supports vendor-specific features on MEKs. The KMB itself only supports fundamental functionalities in order to minimize attack surfaces on MEKs. Moreover, vendors are free to design and implement their own MEK-related functionality within the encryption engine, as long as that functionality cannot be used to exfiltrate MEKs. In order to support these functionalities, some data may be associated and stored with an MEK, and the **AUX** field facilitates this association.

When the drive firmware instructs the KMB to load an MEK, the drive firmware is expected to provide an **AUX** value. Similar to the **METD** field, the KMB will write the **AUX** value into the Auxiliary Data register without any modification.

One simple use case of the **AUX** field is to store an offset of initialization vector or nonce. It can also be used in a more complicated use case. Here is an example. Suppose that there exists a vendor who wants to design a system which supports several modes of operation through the encryption engine while using the KMB. Then, a structure of **AUX** value as on @fig:aux-register-format-example can be used.

![Auxiliary data format example](./diagrams/aux_register_iv_nonce.drawio.svg){#fig:aux-register-format-example}

When the drive firmware instructs KMB to load an MEK, the drive firmware can use the **AUX** value to specify which mode of operation should be used and which value should be used as an initialization vector or a nonce with the generated MEK.

##### Media Encryption Key register

Table: Offset SFR_Base + 40h: MEK – Media Encryption Key {#tbl:ee-mek-sfr}

+-------+------+-------+----------------------------------------------------------+
| Bytes | Type | Reset | Description                                              |
+=======+======+=======+==========================================================+
| 63:00 | WO   | 0h    | **Media encryption key:** This field specifies a 512-bit |
|       |      |       | encryption key.                                          |
+-------+------+-------+----------------------------------------------------------+

The encryption engine is free to interpret the provided key in a vendor-defined manner. One sample interpretation for AES-XTS-256 is presented in @fig:mek-format-example-for-aes.

![MEK format example for AES-XTS-256](./diagrams/mek_register_aes_xts_256.drawio.svg){#fig:mek-format-example-for-aes}

If an algorithm used by the encryption engine does not require 512 bits of key material, the encryption engine is free to disregard unused bits.

Within KMB, loaded MEKs are only ever present in the Key Vault, so that they can be protected against firmware-level attacks. KMB will write MEKs into the encryption engine's key cache using the DMA engine. Given an index and a destination identifier, the DMA engine will copy the key value stored in the given key vault slot to the destination address to which the DMA engine translates the destination identifier.

#### AES-XTS key validation requirements

FIPS 140-3 IG [@{fips-140-3-ig}] section C.I states that in AES-XTS, the key is "parsed as the concatenation of two AES keys, denoted by *Key_1* and *Key_2*, that are 128 [or 256] bits long... The module **shall** check explicitly that *Key_1* ≠ *Key_2*, regardless of how *Key_1* and *Key_2* are obtained."

The encryption engine will be responsible for performing this check when in AES-XTS mode. If the check fails, the encryption engine must report a vendor-defined error. This document does not specify how drive firmware should handle this error case.

#### KMB command sequence

@fig:cmd-ee-example-uml shows a sample command execution. This is an expected sequence when the drive firmware instructs the KMB to load an MEK. This sequence would occur as part of the [DERIVE_MEK](#sec:derive-mek-cmd) or [LOAD_MEK](#sec:load-mek-cmd) mailbox commands. The internal behavior of the encryption engine is one of several possible mechanisms, and can be different per vendor.

```plantuml {caption="Command execution example for loading an MEK" #fig:cmd-ee-example-uml}
!include diagrams/uml/cmd_ee_example.uml
```

### Mailbox interface {#sec:mailbox-interface}

This section provides the mailbox commands exposed by Caliptra as part of OCP L.O.C.K.

Each of these commands returns a \`fips_status\` field. This provides an indicator of whether KMB is operating in FIPS mode. @tbl:fips-status-values provides the possible values for this field.

Note: all multi-byte fields (i.e. \`u16\` and \`u32\`) that are not byte arrays are interpreted as little endian.

Table: Values for the FIPS status field {#tbl:fips-status-values}

+-------------+--------------------+
| Value       | Description        |
+=============+====================+
| 0h          | FIPS mode enabled. |
+-------------+--------------------+
| 1h to FFFFh | Reserved.          |
+-------------+--------------------+

Each mailbox command that causes a command to execute on the encryption engine includes a \`cmd_timeout\` value indicating the amount of time KMB firmware will wait until the command has completed. If this timeout is exceeded, KMB aborts the command and reports a \`LOCK_ENGINE_TIMEOUT\` result code.

KMB firmware will return a \`LOCK_EE_NOT_READY\` error immediately if the encryption engine is not ready to execute a command.

#### GET_STATUS

Exposes a command that allows drive firmware to determine if the encryption engine is ready to process commands as well vendor-defined drive encryption engine status data.

Command Code: 0x4753_5441 ("GSTA")

Table: GET_STATUS input arguments

+--------+------+--------------------------------------------------------------+
| Name   | Type | Description                                                  |
+========+======+==============================================================+
| chksum | u32  | Checksum over other input arguments, computed by the caller. |
+--------+------+--------------------------------------------------------------+

Table: GET_STATUS output arguments

+---------------+--------+--------------------------------------------------------+
| Name          | Type   | Description                                            |
+===============+========+========================================================+
| chksum        | u32    | Checksum over other output arguments, computed by      |
|               |        | Caliptra.                                              |
+---------------+--------+--------------------------------------------------------+
| fips_status   | u32    | Indicates if the command is FIPS approved or an error. |
+---------------+--------+--------------------------------------------------------+
| reserved      | u32[4] | Reserved.                                              |
+---------------+--------+--------------------------------------------------------+
| ctrl_register | u32    | Value of the [CTRL register](#sec:control-register)    |
|               |        | from the SFR interface.                                |
+---------------+--------+--------------------------------------------------------+

#### GET_ALGORITHMS

Exposes a command that allows drive firmware to determine the types of algorithms supported by KMB for endorsement, KEM, MPK, and access key generation.

Command Code: 0x4741_4C47 ("GALG")

Table: GET_ALGORITHMS input arguments

+--------+------+--------------------------------------------------------------+
| Name   | Type | Description                                                  |
+========+======+==============================================================+
| chksum | u32  | Checksum over other input arguments, computed by the caller. |
+--------+------+--------------------------------------------------------------+

Table: GET_ALGORITHMS output arguments {#tbl:get-algorithms-output-args}

+------------------------+--------+---------------------------------------------------+
| Name                   | Type   | Description                                       |
+========================+========+===================================================+
| chksum                 | u32    | Checksum over other output arguments, computed by |
|                        |        | Caliptra.                                         |
+------------------------+--------+---------------------------------------------------+
| fips_status            | u32    | Indicates if the command is FIPS approved or an   |
|                        |        | error.                                            |
+------------------------+--------+---------------------------------------------------+
| reserved               | u32[4] | Reserved.                                         |
+------------------------+--------+---------------------------------------------------+
| endorsement_algorithms | u32    | Identifies the supported endorsement algorithms:  |
|                        |        |                                                   |
|                        |        | - Byte 0 bit 0: ecdsa_secp384r1_sha384            |
|                        |        | [@{ietf-rfc8446}]                                 |
|                        |        | - Byte 0 bit 1: ml-dsa-87                         |
|                        |        | [@{draft-ietf-lamps-dilithium-certificates}]      |
+------------------------+--------+---------------------------------------------------+
| hpke_algorithms        | u32    | Identifies the supported HPKE algorithms:         |
|                        |        | {kem/aead/kdf}_id                                 |
|                        |        |                                                   |
|                        |        | - Byte 0 bit 0: 0x0011, 0x0002, 0x0002            |
|                        |        | [@{ietf-rfc9180}]                                 |
|                        |        | - Byte 0 bit 1: 0x0a25, 0x0002, 0x0002            |
|                        |        | [@{draft-irtf-cfrg-hybrid-kems}]                  |
+------------------------+--------+---------------------------------------------------+
| access_key_sizes       | u32    | Indicates the length of plaintext access keys:    |
|                        |        |                                                   |
|                        |        | - Byte 0 bit 0: 256 bits                          |
+------------------------+--------+---------------------------------------------------+

Each of the \`endorsement_algorithms\`, \`hpke_algorithms\`, and \`access_key_sizes\` fields shall be reported as a non-zero value.

#### CLEAR_KEY_CACHE

This command unloads all MEKs in the encryption engine and deletes all keys in KMB.

Command Code: 0x434C_4B43 ("CLKC")

Table: CLEAR_KEY_CACHE input arguments

+-------------+------+---------------------------------------------------------+
| Name        | Type | Description                                             |
+=============+======+=========================================================+
| chksum      | u32  | Checksum over other input arguments, computed by the    |
|             |      | caller.                                                 |
+-------------+------+---------------------------------------------------------+
| reserved    | u32  | Reserved.                                               |
+-------------+------+---------------------------------------------------------+
| cmd_timeout | u32  | Timeout in ms for command to encryption engine to       |
|             |      | complete.                                               |
+-------------+------+---------------------------------------------------------+

Table: CLEAR_KEY_CACHE output arguments

+-------------+------+--------------------------------------------------------+
| Name        | Type | Description                                            |
+=============+======+========================================================+
| chksum      | u32  | Checksum over other output arguments, computed by      |
|             |      | Caliptra.                                              |
+-------------+------+--------------------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved or an error. |
+-------------+------+--------------------------------------------------------+
| reserved    | u32  | Reserved.                                              |
+-------------+------+--------------------------------------------------------+

#### ENDORSE_ENCAPSULATION_PUB_KEY

This command generates a signed certificate for the specified KEM using the specified endorsement algorithm.

Command Code: 0x4E45_505B ("EEPK")

Table: ENDORSE_ENCAPSULATION_PUB_KEY input arguments

+-----------------------+------+------------------------------------------------------+
| Name                  | Type | Description                                          |
+=======================+======+======================================================+
| chksum                | u32  | Checksum over other input arguments, computed by the |
|                       |      | caller.                                              |
+-----------------------+------+------------------------------------------------------+
| reserved              | u32  | Reserved.                                            |
+-----------------------+------+------------------------------------------------------+
| kem_handle            | u32  | Handle for KEM keypair held in KMB memory.           |
+-----------------------+------+------------------------------------------------------+
| endorsement_algorithm | u32  | Endorsement algorithm identifier. If 0h, then just   |
|                       |      | return public key.                                   |
+-----------------------+------+------------------------------------------------------+

Table: ENDORSE_ENCAPSULATION_PUB_KEY output arguments

+-----------------+---------------------+------------------------------------------------+
| Name            | Type                | Description                                    |
+=================+=====================+================================================+
| chksum          | u32                 | Checksum over other output arguments, computed |
|                 |                     | by Caliptra.                                   |
+-----------------+---------------------+------------------------------------------------+
| fips_status     | u32                 | Indicates if the command is FIPS approved or   |
|                 |                     | an error.                                      |
+-----------------+---------------------+------------------------------------------------+
| reserved        | u32                 | Reserved.                                      |
+-----------------+---------------------+------------------------------------------------+
| pub_key_len     | u32                 | Length of HPKE public key                      |
|                 |                     | (\`Npk\` in RFC 9180).                         |
+-----------------+---------------------+------------------------------------------------+
| endorsement_len | u32                 | Length of endorsement data. Zero if            |
|                 |                     | \`endorsement_algorithm\` is 0h.               |
+-----------------+---------------------+------------------------------------------------+
| pub_key         | u8[pub_key_len]     | HPKE public key.                               |
+-----------------+---------------------+------------------------------------------------+
| endorsement     | u8[endorsement_len] | DER-encoded X.509 certificate.                 |
+-----------------+---------------------+------------------------------------------------+

#### ROTATE_ENCAPSULATION_KEY

This command rotates the KEM keypair indicated by the specified handle and stores the new KEM keypair in volatile memory within KMB.

Command Code: 0x5245_4E4B ("RENK")

Table: ROTATE_ENCAPSULATION_KEY input arguments

+------------+------+------------------------------------------------------+
| Name       | Type | Description                                          |
+============+======+======================================================+
| chksum     | u32  | Checksum over other input arguments, computed by the |
|            |      | caller.                                              |
+------------+------+------------------------------------------------------+
| reserved   | u32  | Reserved.                                            |
+------------+------+------------------------------------------------------+
| kem_handle | u32  | Handle for old KEM keypair held in KMB memory.       |
+------------+------+------------------------------------------------------+

Table: ROTATE_ENCAPSULATION_KEY output arguments

+-------------+------+------------------------------------------------+
| Name        | Type | Description                                    |
+=============+======+================================================+
| chksum      | u32  | Checksum over other output arguments, computed |
|             |      | by Caliptra.                                   |
+-------------+------+------------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved or   |
|             |      | an error.                                      |
+-------------+------+------------------------------------------------+
| reserved    | u32  | Reserved.                                      |
+-------------+------+------------------------------------------------+
| kem_handle  | u32  | Handle for new KEM keypair held in KMB memory. |
+-------------+------+------------------------------------------------+

#### GENERATE_MPK

This command unwraps the specified access key, generates a random MPK, then uses the HEK and access key to encrypt the MPK which is returned for the drive to persistently store. The given \`uid\` is placed in the  \`aad\` field of the returned MPK to cryptographically tie the UID to the MPK.

Command Code: 0x474D_504B ("GMPK")

Table: GENERATE_MPK input arguments

+-------------------+-----------------+----------------------------------------+
| Name              | Type            | Description                            |
+===================+=================+========================================+
| chksum            | u32             | Checksum over other input arguments,   |
|                   |                 | computed by the caller.                |
+-------------------+-----------------+----------------------------------------+
| reserved          | u32             | Reserved.                              |
+-------------------+-----------------+----------------------------------------+
| uid_len           | u32             | Length of the uid argument.            |
+-------------------+-----------------+----------------------------------------+
| info_len          | u32             | Length of the info argument.           |
+-------------------+-----------------+----------------------------------------+
| uid               | u8[uid_len]     | Unique identifier for the MPK.         |
+-------------------+-----------------+----------------------------------------+
| info              | u8[info_len]    | Info argument to use with HPKE unwrap. |
+-------------------+-----------------+----------------------------------------+
| sealed_access_key | SealedAccessKey | HPKE-sealed access key.                |
+-------------------+-----------------+----------------------------------------+

Table: GENERATE_MPK output arguments

+---------------+-----------+------------------------------------------------+
| Name          | Type      | Description                                    |
+===============+===========+================================================+
| chksum        | u32       | Checksum over other output arguments, computed |
|               |           | by Caliptra.                                   |
+---------------+-----------+------------------------------------------------+
| fips_status   | u32       | Indicates if the command is FIPS approved or   |
|               |           | an error.                                      |
+---------------+-----------+------------------------------------------------+
| reserved      | u32       | Reserved.                                      |
+---------------+-----------+------------------------------------------------+
| encrypted_mpk | LockedMpk | MPK encrypted to access_key.                   |
+---------------+-----------+------------------------------------------------+

#### REWRAP_MPK

This command unwraps old_access_key and encrypted new_access_key from sealed_access_keys. Then old_access_key is used to decrypt new_access_key. The specified MPK is decrypted using KDF(HEK, "MPK", old_access_key). A new MPK is encrypted with the output of KDF(HEK, "MPK", new_access_key). The new encrypted MPK is returned.

The drive stores the returned new encrypted MPK. The drive may attempt to do a trial decryption of the new MPK without an error before deleting the old MPK. Drive firmware zeroizes the old encrypted MPK.

Command Code: 0x5245_5750 ("REWP")

Table: REWRAP_MPK input arguments

+--------------------+--------------------------+------------------------------+
| Name               | Type                     | Description                  |
+====================+==========================+==============================+
| chksum             | u32                      | Checksum over other          |
|                    |                          | input arguments,             |
|                    |                          | computed by the caller.      |
+--------------------+--------------------------+------------------------------+
| reserved           | u32                      | Reserved.                    |
+--------------------+--------------------------+------------------------------+
| info_len           | u32                      | Length of the info argument. |
+--------------------+--------------------------+------------------------------+
| info               | u8[info_len]             | Info argument to use with    |
|                    |                          | HPKE unwrap.                 |
+--------------------+--------------------------+------------------------------+
| old_locked_mpk     | LockedMpk                | Old MPK to be rewrapped.     |
+--------------------+--------------------------+------------------------------+
| sealed_access_keys | SealedOldAndNewAccessKey | HPKE-sealed old_access_key.  |
|                    |                          | HPKE-sealed (new_access_key  |
|                    |                          | encrypted to                 |
|                    |                          | old_access_key).             |
+--------------------+--------------------------+------------------------------+

Table: REWRAP_MPK output arguments

+----------------+-----------+-------------------------------------------+
| Name           | Type      | Description                               |
+================+===========+===========================================+
| chksum         | u32       | Checksum over other output arguments,     |
|                |           | computed by Caliptra.                     |
+----------------+-----------+-------------------------------------------+
| fips_status    | u32       | Indicates if the command is FIPS approved |
|                |           | or an error.                              |
+----------------+-----------+-------------------------------------------+
| reserved       | u32       | Reserved.                                 |
+----------------+-----------+-------------------------------------------+
| new_locked_mpk | LockedMpk | MPK encrypted to new_access_key.          |
+----------------+-----------+-------------------------------------------+

#### READY_MPK

This command decrypts \`sealed_access_key\`. Then the decrypted access_key is used to decrypt \`locked_mpk\` using KDF(HEK, "MPK", access_key). A "ready" MPK is encrypted with the Ready MPK Encryption Key. The encrypted ready MPK is returned.

Command Code: 0x524D_504B ("RMPK")

Table: READY_MPK input arguments

+-------------------+-----------------+------------------------------+
| Name              | Type            | Description                  |
+===================+=================+==============================+
| chksum            | u32             | Checksum over other          |
|                   |                 | input arguments,             |
|                   |                 | computed by the caller.      |
+-------------------+-----------------+------------------------------+
| reserved          | u32             | Reserved.                    |
+-------------------+-----------------+------------------------------+
| info_len          | u32             | Length of the info argument. |
+-------------------+-----------------+------------------------------+
| info              | u8[info_len]    | Info argument to use with    |
|                   |                 | HPKE unwrap.                 |
+-------------------+-----------------+------------------------------+
| sealed_access_key | SealedAccessKey | HPKE-sealed access key.      |
+-------------------+-----------------+------------------------------+
| locked_mpk        | LockedMpk       | MPK encrypted to the HEK and |
|                   |                 | access key.                  |
+-------------------+-----------------+------------------------------+

Table: READY_MPK output arguments

+-------------+----------+--------------------------------------------+
| Name        | Type     | Description                                |
+=============+==========+============================================+
| chksum      | u32      | Checksum over other output arguments,      |
|             |          | computed by Caliptra.                      |
+-------------+----------+--------------------------------------------+
| fips_status | u32      | Indicates if the command is FIPS approved  |
|             |          | or an error.                               |
+-------------+----------+--------------------------------------------+
| reserved    | u32      | Reserved.                                  |
+-------------+----------+--------------------------------------------+
| ready_mpk   | ReadyMpk | MPK encrypted to Ready MPK Encryption Key. |
+-------------+----------+--------------------------------------------+

#### MIX_MPK

This command initializes the MEK secret seed if not already initialized or if \`initialize\` is set to 1, decrypts the specified MPK with the with the Ready MPK Encryption Key, and then updates the MEK secret seed in KMB by performing a KDF with the MEK secret seed and the decrypted MPK.

When generating an MEK, one or more MIX_MPK commands are processed to modify the MEK secret seed.

Command Code: 0x4D4D_504B ("MMPK")

Table: MIX_MPK input arguments

+------------+----------+--------------------------------------------------+
| Name       | Type     | Description                                      |
+============+==========+==================================================+
| chksum     | u32      | Checksum over other input arguments,             |
|            |          | computed by the caller.                          |
+------------+----------+--------------------------------------------------+
| reserved   | u32      | Reserved.                                        |
+------------+----------+--------------------------------------------------+
| initialize | u32      | If set to 1, the MEK secret seed is              |
|            |          | initialized before the given MPK is              |
|            |          | mixed. All other values reserved. Little-endian. |
+------------+----------+--------------------------------------------------+
| ready_mpk  | ReadyMpk | MPK encrypted to the Ready MPK Encryption Key.   |
+------------+----------+--------------------------------------------------+

Table: MIX_MPK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### TEST_ACCESS_KEY

This command is used by the host to check the correct access key is associated with the given MPK. The \`nonce\` is a random value to be included in the digest calculation to prevent response replay attacks. The output is calculated as SHA2-384(UID || decrypted access key || nonce). The UID is taken from the provided MPK's \`aad\` field.

Command Code: 0x5441_434B ("TACK")

Table: TEST_ACCESS_KEY input arguments

+-------------------+-----------------+---------------------------------------+
| Name              | Type            | Description                           |
+===================+=================+=======================================+
| nonce             | u8[32]          | Host provided random value.           |
+-------------------+-----------------+---------------------------------------+
| locked_mpk        | LockedMpk       | Locked MPK associated with the access |
|                   |                 | key.                                  |
+-------------------+-----------------+---------------------------------------+
| sealed_access_key | SealedAccessKey | HPKE-sealed access key.               |
+-------------------+-----------------+---------------------------------------+

Table: TEST_ACCESS_KEY output arguments

+--------+--------+------------------------------------------------------+
| Name   | Type   | Description                                          |
+========+========+======================================================+
| digest | u8[48] | SHA-384 hash of the MPK's UID, decrypted access key, |
|        |        | and nonce.                                           |
+--------+--------+------------------------------------------------------+

#### GENERATE_MEK

This command generates a random 512-bit MEK and encrypts it using the MEK encryption key, which is derived from the HEK, the MEK secret seed, and the given SEK and DPK.

The DPK may be a value decrypted by a user-provided C_PIN in Opal.

When generating an MEK, the MEK secret seed is initialized if no MPK has previously been mixed into the MEK secret seed.

Command Code: 0x474D_454B ("GMEK")

Table: GENERATE_MEK input arguments

+----------+--------+---------------------------------------------+
| Name     | Type   | Description                                 |
+==========+========+=============================================+
| chksum   | u32    | Checksum over other input arguments,        |
|          |        | computed by the caller.                     |
+----------+--------+---------------------------------------------+
| reserved | u32    | Reserved.                                   |
+----------+--------+---------------------------------------------+
| sek      | u8[32] | "Soft epoch key". May be rotated            |
|          |        | by the drive as part of a cryptographic     |
|          |        | erase.                                      |
+----------+--------+---------------------------------------------+
| dpk      | u8[32] | "Data protection key". May be a value       |
|          |        | decrypted by a user-provided C_PIN in Opal. |
+----------+--------+---------------------------------------------+

Table: GENERATE_MEK output arguments

+-------------+------------+-------------------------------------------+
| Name        | Type       | Description                               |
+=============+============+===========================================+
| chksum      | u32        | Checksum over other output arguments,     |
|             |            | computed by Caliptra.                     |
+-------------+------------+-------------------------------------------+
| fips_status | u32        | Indicates if the command is FIPS approved |
|             |            | or an error.                              |
+-------------+------------+-------------------------------------------+
| reserved    | u32        | Reserved.                                 |
+-------------+------------+-------------------------------------------+
| wrapped_mek | WrappedMek | MEK encrypted to the derived MEK          |
|             |            | encryption key.                           |
+-------------+------------+-------------------------------------------+

#### LOAD_MEK {#sec:load-mek-cmd}

This command decrypts the given encrypted 512-bit MEK using the MEK encryption key, which is derived from the HEK, the MEK secret seed, and the given SEK and DPK.

The DPK may be a value decrypted by a user-provided C_PIN in Opal.

When decrypting an MEK, the MEK secret seed is initialized if no MPK has previously been mixed into the MEK secret seed.

The decrypted MEK, specified metadata, and aux_metadata are loaded into the encryption engine key cache. The metadata format is vendor-defined and specifies the information to the encryption engine on where within the key cache the MEK is loaded.

Command Code: 0x4C4D_454B ("LMEK")

Table: LOAD_MEK input arguments

+--------------+------------+-----------------------------------------------+
| Name         | Type       | Description                                   |
+==============+============+===============================================+
| chksum       | u32        | Checksum over other input arguments,          |
|              |            | computed by the caller.                       |
+--------------+------------+-----------------------------------------------+
| reserved     | u32        | Reserved.                                     |
+--------------+------------+-----------------------------------------------+
| sek          | u8[32]     | "Soft epoch key". May be rotated              |
|              |            | by the drive as part of a cryptographic       |
|              |            | erase.                                        |
+--------------+------------+-----------------------------------------------+
| dpk          | u8[32]     | "Data protection key". May be a value         |
|              |            | decrypted by a user-provided C_PIN in Opal.   |
+--------------+------------+-----------------------------------------------+
| metadata     | u8[20]     | Metadata for MEK to load into the drive       |
|              |            | encryption engine (i.e. NSID + LBA range).    |
+--------------+------------+-----------------------------------------------+
| aux_metadata | u8[32]     | Auxiliary metadata for the MEK                |
|              |            | (optional; i.e. operation mode).              |
+--------------+------------+-----------------------------------------------+
| wrapped_mek  | WrappedMek | MEK encrypted to the derived MEK encryption   |
|              |            | key.                                          |
+--------------+------------+-----------------------------------------------+
| cmd_timeout  | u32        | Timeout in ms for command to encryption       |
|              |            | engine to complete.                           |
+--------------+------------+-----------------------------------------------+

Table: LOAD_MEK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### DERIVE_MEK {#sec:derive-mek-cmd}

This command derives an MEK using the HEK, the MEK secret seed, and the given SEK and DPK.

When deriving an MEK, the MEK secret seed is initialized if no MPK has previously been mixed into the MEK secret seed.

The derived MEK, specified metadata, and aux_metadata are loaded into the encryption engine key cache. The metadata format is vendor-defined and specifies the information to the encryption engine on where within the key cache the MEK is loaded.

Command Code: 0x444D_454B ("DMEK")

Table: DERIVE_MEK input arguments

+--------------+--------+-----------------------------------------------+
| Name         | Type   | Description                                   |
+==============+========+===============================================+
| chksum       | u32    | Checksum over other input arguments,          |
|              |        | computed by the caller.                       |
+--------------+--------+-----------------------------------------------+
| reserved     | u32    | Reserved.                                     |
+--------------+--------+-----------------------------------------------+
| sek          | u8[32] | "Soft epoch key". May be rotated              |
|              |        | by the drive as part of a cryptographic       |
|              |        | erase.                                        |
+--------------+--------+-----------------------------------------------+
| dpk          | u8[32] | "Data protection key".                        |
+--------------+--------+-----------------------------------------------+
| metadata     | u8[20] | Metadata for MEK to load into the drive       |
|              |        | encryption engine (i.e. NSID + LBA range).    |
+--------------+--------+-----------------------------------------------+
| aux_metadata | u8[32] | Auxiliary metadata for the MEK                |
|              |        | (optional; i.e. operation mode).              |
+--------------+--------+-----------------------------------------------+
| cmd_timeout  | u32    | Timeout in ms for command to encryption       |
|              |        | engine to complete.                           |
+--------------+--------+-----------------------------------------------+

Table: DERIVE_MEK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### UNLOAD_MEK

This command causes the MEK associated to the specified metadata to be unloaded for the key cache of the encryption engine. The metadata format is vendor-defined and specifies the information to the encryption engine on where within the key cache, the MEK is loaded.

Command Code: 0x554D_454B ("UMEK")

Table: UNLOAD_MEK input arguments

+-------------+--------+-----------------------------------------------+
| Name        | Type   | Description                                   |
+=============+========+===============================================+
| chksum      | u32    | Checksum over other input arguments,          |
|             |        | computed by the caller.                       |
+-------------+--------+-----------------------------------------------+
| reserved    | u32    | Reserved.                                     |
+-------------+--------+-----------------------------------------------+
| metadata    | u8[20] | Metadata for MEK to unload from the drive     |
|             |        | encryption engine (i.e. NSID + LBA range).    |
+-------------+--------+-----------------------------------------------+
| cmd_timeout | u32    | Timeout in ms for command to encryption       |
|             |        | engine to complete.                           |
+-------------+--------+-----------------------------------------------+

Table: UNLOAD_MEK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### ENUMERATE_KEM_HANDLES {#sec:enumerate-kem-handles}

This command returns a list of all currently-active KEM handles for resources held by KMB.

Command Code: 0x4548_444C ("EHDL")

Table: ENUMERATE_KEM_HANDLES input arguments

+----------+------+--------------------------------------+
| Name     | Type | Description                          |
+==========+======+======================================+
| chksum   | u32  | Checksum over other input arguments, |
|          |      | computed by the caller.              |
+----------+------+--------------------------------------+
| reserved | u32  | Reserved.                            |
+----------+------+--------------------------------------+

Table: ENUMERATE_KEM_HANDLES output arguments

+------------------+--------------+-------------------------------------------+
| Name             | Type         | Description                               |
+==================+==============+===========================================+
| chksum           | u32          | Checksum over other output arguments,     |
|                  |              | computed by Caliptra.                     |
+------------------+--------------+-------------------------------------------+
| fips_status      | u32          | Indicates if the command is FIPS approved |
|                  |              | or an error.                              |
+------------------+--------------+-------------------------------------------+
| reserved         | u32          | Reserved.                                 |
+------------------+--------------+-------------------------------------------+
| kem_handle_count | u32          | Number of KEM handles (N).                |
+------------------+--------------+-------------------------------------------+
| kem_handles      | KemHandle[N] | List of (KEM handle value, KEM algorithm) |
|                  |              | tuples.                                   |
+------------------+--------------+-------------------------------------------+

Table: KemHandle contents

+----------------+------+--------------------------------------------+
| Name           | Type | Description                                |
+================+======+============================================+
| handle         | u32  | Handle for KEM keypair held in KMB memory. |
+----------------+------+--------------------------------------------+
| hpke_algorithm | u32  | HPKE algorithm. Shall be a bit value       |
|                |      | indicated as supported in                  |
|                |      | @tbl:get-algorithms-output-args.           |
+----------------+------+--------------------------------------------+

#### ZEROIZE_CURRENT_HEK {#sec:zeroize-current-hek-cmd}

This command programs all un-programmed bits in the current HEK slot, so all bits are programmed. May re-attempt a previously-failed zeroize operation.

Command Code: 0x5A43_484B ("ZCHK")

Table: ZEROIZE_CURRENT_HEK input arguments

+----------+------+-----------------------------------------------+
| Name     | Type | Description                                   |
+==========+======+===============================================+
| chksum   | u32  | Checksum over other input arguments, computed |
|          |      | by the caller.                                |
+----------+------+-----------------------------------------------+
| reserved | u32  | Reserved.                                     |
+----------+------+-----------------------------------------------+
| hek_slot | u32  | Current HEK slot to zeroize.                  |
+----------+------+-----------------------------------------------+

Table: ZEROIZE_CURRENT_HEK output arguments

+-------------+------+------------------------------------------------+
| Name        | Type | Description                                    |
+=============+======+================================================+
| chksum      | u32  | Checksum over other output arguments, computed |
|             |      | by Caliptra.                                   |
+-------------+------+------------------------------------------------+
| reserved    | u32  | Reserved.                                      |
+-------------+------+------------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved      |
|             |      | or an error.                                   |
+-------------+------+------------------------------------------------+

#### PROGRAM_NEXT_HEK {#sec:program-next-hek-cmd}

This command generates a random key and programs it into the next-available HEK slot.

Command Code: 0x504E_484B ("PNHK")

Table: PROGRAM_NEXT_HEK input arguments

+----------+------+--------------------------------------+
| Name     | Type | Description                          |
+==========+======+======================================+
| chksum   | u32  | Checksum over other input arguments, |
|          |      | computed by the caller.              |
+----------+------+--------------------------------------+
| reserved | u32  | Reserved.                            |
+----------+------+--------------------------------------+
| hek_slot | u32  | Next HEK slot to program.            |
+----------+------+--------------------------------------+

Table: PROGRAM_NEXT_HEK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### ENABLE_PERMANENT_HEK {#sec:enable-permanent-hek-cmd}

This command enables a state where the HEK is derived from non-ratchetable secrets. The command is only allowed once all HEK fuse slots are programmed and zeroized.

Command Code: 0x4550_484B ("EPHK")

Table: ENABLE_PERMANENT_HEK input arguments

+----------+------+--------------------------------------+
| Name     | Type | Description                          |
+==========+======+======================================+
| chksum   | u32  | Checksum over other input arguments, |
|          |      | computed by the caller.              |
+----------+------+--------------------------------------+
| reserved | u32  | Reserved.                            |
+----------+------+--------------------------------------+

Table: ENABLE_PERMANENT_HEK output arguments

+-------------+------+-------------------------------------------+
| Name        | Type | Description                               |
+=============+======+===========================================+
| chksum      | u32  | Checksum over other output arguments,     |
|             |      | computed by Caliptra.                     |
+-------------+------+-------------------------------------------+
| fips_status | u32  | Indicates if the command is FIPS approved |
|             |      | or an error.                              |
+-------------+------+-------------------------------------------+
| reserved    | u32  | Reserved.                                 |
+-------------+------+-------------------------------------------+

#### REPORT_EPOCH_KEY_STATE

This command reports the state of the epoch keys. The drive indicates the state of the SEK, while KMB internally senses the state of the HEK.

Command Code: 0x5245_4B53 ("REKS")

Table: REPORT_EPOCH_KEY_STATE input arguments

+-----------+--------+---------------------------------------+
| Name      | Type   | Description                           |
+===========+========+=======================================+
| chksum    | u32    | Checksum over other input arguments,  |
|           |        | computed by the caller.               |
+-----------+--------+---------------------------------------+
| reserved  | u32    | Reserved.                             |
+-----------+--------+---------------------------------------+
| sek_state | u16    | SEK state. See @tbl:sek-state-values. |
+-----------+--------+---------------------------------------+
| nonce     | u8[16] | Freshness nonce.                      |
+-----------+--------+---------------------------------------+

Table: REPORT_EPOCH_KEY_STATE output arguments

+-----------------+-------------+----------------------------------------------+
| Name            | Type        | Description                                  |
+=================+=============+==============================================+
| chksum          | u32         | Checksum over other output arguments,        |
|                 |             | computed by Caliptra.                        |
+-----------------+-------------+----------------------------------------------+
| fips_status     | u32         | Indicates if the command is FIPS approved    |
|                 |             | or an error.                                 |
+-----------------+-------------+----------------------------------------------+
| reserved        | u32         | Reserved.                                    |
+-----------------+-------------+----------------------------------------------+
| total_hek_slots | u16         | Total number of HEK slots.                   |
+-----------------+-------------+----------------------------------------------+
| active_hek_slot | u16         | Currently-active HEK slot.                   |
+-----------------+-------------+----------------------------------------------+
| hek_state       | u16         | State of the currently-active HEK. See       |
|                 |             | @tbl:hek-state-values.                       |
+-----------------+-------------+----------------------------------------------+
| next_action     | u16         | A bit field representation of the next       |
|                 |             | actions that can be taken on the epoch keys. |
|                 |             | See @tbl:next-action-values.                 |
+-----------------+-------------+----------------------------------------------+
| eat_len         | u16         | Total length of the IETF EAT.                |
+-----------------+-------------+----------------------------------------------+
| eat             | u8[eat_len] | CBOR-encoded and signed IETF EAT.            |
|                 |             | See @sec:eat-format for the format.          |
+-----------------+-------------+----------------------------------------------+

Table: SEK state values {#tbl:sek-state-values}

+-------------+-------------+
| Value       | Description |
+=============+=============+
| 0h          | ZEROIZED    |
+-------------+-------------+
| 1h          | PROGRAMMED  |
+-------------+-------------+
| 2h to FFFFh | Reserved    |
+-------------+-------------+

Table: HEK state values {#tbl:hek-state-values}

+-------------+-------------+--------------------------+
| Value       | Description | KMB willing to load MEKs |
|             |             | in this state            |
+=============+=============+==========================+
| 0h          | EMPTY       | No                       |
+-------------+-------------+--------------------------+
| 1h          | ZEROIZED    | No                       |
+-------------+-------------+--------------------------+
| 2h          | INVALID     | No                       |
+-------------+-------------+--------------------------+
| 3h          | PROGRAMMED  | Yes                      |
+-------------+-------------+--------------------------+
| 4h          | PERMANENT   | Yes                      |
+-------------+-------------+--------------------------+
| 5h to FFFFh | Reserved    |                          |
+-------------+-------------+--------------------------+

Table: Next action values {#tbl:next-action-values}

+-------------+----------------------+
| Value       | Command              |
+=============+======================+
| 0h          | PROGRAM_NEXT_SEK     |
+-------------+----------------------+
| 1h          | ZEROIZE_CURRENT_SEK  |
+-------------+----------------------+
| 2h          | PROGRAM_NEXT_HEK     |
+-------------+----------------------+
| 3h          | ZEROIZE_CURRENT_HEK  |
+-------------+----------------------+
| 4h          | ENABLE_PERMANENT_HEK |
+-------------+----------------------+
| 5h to FFFFh | Reserved             |
+-------------+----------------------+

#### Common mailbox types

This section defines common types used to interface between the drive firmware and KMB. These types are common patterns found in both requests and responses.

Table: SealedAccessKey contents

+----------------+-----------------------+------------------------------------------------+
| Name           | Type                  | Description                                    |
+================+=======================+================================================+
| kem_handle     | u32                   | Handle for KEM keypair held in KMB memory.     |
+----------------+-----------------------+------------------------------------------------+
| hpke_algorithm | u32                   | HPKE algorithm. Must be a bit value indicated  |
|                |                       | as supported in                                |
|                |                       | @tbl:get-algorithms-output-args.               |
+----------------+-----------------------+------------------------------------------------+
| access_key_len | u32                   | Access key length in bytes. Must be the scalar |
|                |                       | value associated with a bit value indicated as |
|                |                       | supported in @tbl:get-algorithms-output-args.  |
+----------------+-----------------------+------------------------------------------------+
| kem_ciphertext | u8[Nenc]              | HPKE encapsulated key.                         |
+----------------+-----------------------+------------------------------------------------+
| ak_ct          | u8[access_key_len+Nt] | Access key ciphertext and authentication tag.  |
+----------------+-----------------------+------------------------------------------------+

\`Nenc\` and \`Nt\` are HPKE values associated with the \`kem_id\` and \`aead_id\` identifiers from the given \`hpke_algorithm\`. For example, if byte 0 bit 0 of \`hpke_algorithm\` is set (indicating \`kem_id\` 0x0011 and \`aead_id\` 0x0002), then according to [@{ietf-rfc9180}], \`Nenc\` and \`Nt\` would be 97 and 16, respectively.

Table: SealedOldAndNewAccessKey contents

+-----------------+--------------------------+-----------------------------------------+
| Name            | Type                     | Description                             |
+=================+==========================+=========================================+
| old_access_key  | SealedAccessKey          | Old access key. Used to decrypt the new |
|                 |                          | access key.                             |
+-----------------+--------------------------+-----------------------------------------+
| ak_iv           | u8[Nn]                   | IV used to decrypt the encrypted        |
|                 |                          | access key.                             |
+-----------------+--------------------------+-----------------------------------------+
| encrypted_ak_ct | u8[access_key_len+Nt+Nt] | (Encrypted access key + inner tag)      |
|                 |                          | ciphertext and outer tag.               |
+-----------------+--------------------------+-----------------------------------------+

\`Nn\` and \`Nt\` are HPKE values associated with the \`aead_id\` identifier from the given \`hpke_algorithm\`.

The outer layer of encryption of the wrapped access key is decrypted using HPKE. The inner layer is decrypted using the access key in the accompanying \`SealedAccessKey\` instance. Both layers use the AEAD algorithm indicated by the \`aead_id\` identifier from the given \`hpke_algorithm\`.

##### WrappedKey type

AES-256-GCM is used for all wrapping and unwrapping.

Table: WrappedKey contents

+----------+-------------+--------------------------------------------+
| Name     | Type        | Description                                |
+==========+=============+============================================+
| key_type | u16         | Type of the wrapped key. This is treated   |
|          |             | as AAD when the key is decrypted.          |
|          |             |                                            |
|          |             | - 0h: Reserved                             |
|          |             | - 1h: LOCKED_MPK (ciphertext held at rest) |
|          |             | - 2h: READY_MPK (ciphertext held in RAM)   |
|          |             | - 3h: WRAPPED_MEK                          |
|          |             | - 4h to FFFFh: Reserved                    |
+----------+-------------+--------------------------------------------+
| reserved | u16         | Reserved.                                  |
+----------+-------------+--------------------------------------------+
| aad_len  | u32         | Length of the aad field.                   |
+----------+-------------+--------------------------------------------+
| ct_len   | u32         | Length of the ct field.                    |
+----------+-------------+--------------------------------------------+
| iv       | u8[12]      | Initialization vector for AES operation.   |
+----------+-------------+--------------------------------------------+
| aad      | u8[aad_len] | Additional authenticated data to be added  |
|          |             | to the GCM tag calculation.                |
+----------+-------------+--------------------------------------------+
| ct       | u8[ct_len]  | Key ciphertext and authentication tag.     |
+----------+-------------+--------------------------------------------+

Variants of WrappedKey will be used to reduce duplicating information in commands. The following names will be used for WrappedKeys of a specific \`key_type\` and \`ct_len\`:

Table: WrappedKey variants

+------------+--------------+------------+
| Name       | \`key_type\` | \`ct_len\` |
+============+==============+============+
| LockedMpk  | LOCKED_MPK   | 32         |
+------------+--------------+------------+
| ReadyMpk   | READY_MPK    | 32         |
+------------+--------------+------------+
| WrappedMek | WRAPPED_MEK  | 64         |
+------------+--------------+------------+

#### Fault handling

A KMB mailbox command can fail to complete in the following ways:

- An ill-formed command.
- Encryption engine timeout.
- Encryption engine reported error.

In all of these cases, the error is reported in the command return status.

Depending on the type of fault, drive firmware may resubmit the mailbox command.

Table: KMB mailbox command result codes {#tbl:kmb-mailbox-codes}

+------------------------+-------------+--------------------------+
| Name                   | Value       | Description              |
+========================+=============+==========================+
| LOCK_ENGINE_TIMEOUT    | 0x4C45_544F | Timeout occurred when    |
|                        | ("LETO")    | communicating with the   |
|                        |             | drive encryption engine  |
|                        |             | to execute a command     |
+------------------------+-------------+--------------------------+
| LOCK_ENGINE_CODE + u16 | 0x4443_xxxx | Vendor-specific error    |
|                        | ("ECxx")    | code in the low 16 bits  |
+------------------------+-------------+--------------------------+
| LOCK_BAD_ALGORITHM     | 0x4C42_414C | Unsupported algorithm,   |
|                        | ("LBAL")    | or algorithm does not    |
|                        |             | match the given handle   |
+------------------------+-------------+--------------------------+
| LOCK_BAD_HANDLE        | 0x4C42_4841 | Unknown handle           |
|                        | ("LBHA")    |                          |
+------------------------+-------------+--------------------------+
| LOCK_NO_HANDLES        | 0x4C4E_4841 | Too many extant handles  |
|                        | ("LNHA")    | exist                    |
+------------------------+-------------+--------------------------+
| LOCK_KEM_DECAPSULATION | 0x4C4B_4445 | Error during KEM         |
|                        | ("LKDE")    | decapsulation            |
+------------------------+-------------+--------------------------+
| LOCK_ACCESS_KEY_UNWRAP | 0x4C41_4B55 | Error during access key  |
|                        | ("LAKU")    | decryption               |
+------------------------+-------------+--------------------------+
| LOCK_MPK_DECRYPT       | 0x4C50_4445 | Error during MPK         |
|                        | ("LPDE")    | decryption               |
+------------------------+-------------+--------------------------+
| LOCK_MEK_DECRYPT       | 0x4C4D_4445 | Error during MEK         |
|                        | ("LMDE")    | decryption               |
+------------------------+-------------+--------------------------+
| LOCK_HEK_INVALID_SLOT  | 0x4C48_4953 | Incorrect HEK slot when  |
|                        | ("LHIS")    | programming or zeroizing |
+------------------------+-------------+--------------------------+
| LOCK_EE_NOT_READY      | 0x4C45_4E52 | Encryption engine was    |
|                        | ("LENR")    | not ready when the       |
|                        |             | command was received.    |
+------------------------+-------------+--------------------------+

##### Fatal errors

This section will be fleshed out with additional details as they become available.

##### Non-fatal errors

This section will be fleshed out with additional details as they become available.

## Terminology

Table: Acronyms and abbreviations used throughout this document {#tbl:abbreviations}

+--------------+----------------------------------------------------------+
| Abbreviation | Description                                              |
+==============+==========================================================+
| AES          | Advanced Encryption Standard                             |
+--------------+----------------------------------------------------------+
| CSP          | Cloud Service Provider                                   |
+--------------+----------------------------------------------------------+
| DPK          | Data Protection Key                                      |
+--------------+----------------------------------------------------------+
| DICE         | Device Identifier Composition Engine                     |
+--------------+----------------------------------------------------------+
| DRBG         | Deterministic Random Bit Generator                       |
+--------------+----------------------------------------------------------+
| ECDH         | Elliptic-curve Diffie–Hellman                            |
+--------------+----------------------------------------------------------+
| ECDSA        | Elliptic Curve Digital Signature Algorithm               |
+--------------+----------------------------------------------------------+
| EPK          | Epoch Protection Key                                     |
+--------------+----------------------------------------------------------+
| HEK          | Hard Epoch Key                                           |
+--------------+----------------------------------------------------------+
| HKDF         | HMAC-based key derivation function                       |
+--------------+----------------------------------------------------------+
| HMAC         | Hash-Based Message Authentication Code                   |
+--------------+----------------------------------------------------------+
| HPKE         | Hybrid Public Key Encryption                             |
+--------------+----------------------------------------------------------+
| IETF EAT     | IETF Entity Attestation Token                            |
+--------------+----------------------------------------------------------+
| KDF          | Key Derivation Function                                  |
+--------------+----------------------------------------------------------+
| KEM          | Key Encapsulation Mechanism                              |
+--------------+----------------------------------------------------------+
| KMB          | Key Management Block                                     |
+--------------+----------------------------------------------------------+
| L.O.C.K.     | Layered Open-Source Cryptographic Key-management         |
+--------------+----------------------------------------------------------+
| MEK          | Media Encryption Key                                     |
+--------------+----------------------------------------------------------+
| ML-KEM       | Module-Lattice-Based Key-Encapsulation Mechanism         |
+--------------+----------------------------------------------------------+
| MPK          | Multi-party Protection Key                               |
+--------------+----------------------------------------------------------+
| NIST         | National Institute of Standards and Technology           |
+--------------+----------------------------------------------------------+
| OCP          | Open Compute Project                                     |
+--------------+----------------------------------------------------------+
| RTL          | Register Transfer Level                                  |
+--------------+----------------------------------------------------------+
| SED          | Self-encrypting drive                                    |
+--------------+----------------------------------------------------------+
| SIK          | Stable Identity Key                                      |
+--------------+----------------------------------------------------------+
| SEK          | Soft Epoch Key                                           |
+--------------+----------------------------------------------------------+
| SSD          | Solid-state drive                                        |
+--------------+----------------------------------------------------------+
| SVN          | Security Version Number                                  |
+--------------+----------------------------------------------------------+
| TCG          | Trusted Computing Group                                  |
+--------------+----------------------------------------------------------+
| UART         | Universal asynchronous receiver-transmitter              |
+--------------+----------------------------------------------------------+
| XTS          | XEX-based tweaked-codebook mode with ciphertext stealing |
+--------------+----------------------------------------------------------+

## Compliance

This section enumerates requirements for devices that integrate OCP L.O.C.K.

Table: Compliance requirements {#tbl:compliance-requirements}

+------+--------------------------------------------------+-----------+
| Item | Requirement                                      | Mandatory |
+======+==================================================+===========+
| 1    | The device shall integrate Caliptra.             | Yes       |
+------+--------------------------------------------------+-----------+
| 2    | OCP L.O.C.K. shall be enabled.                   | Yes       |
+------+--------------------------------------------------+-----------+
| 3    | Media encryption keys shall only be programmable |           |
|      | to the encryption engine via Caliptra.           | Yes       |
+------+--------------------------------------------------+-----------+
| 4    | The encryption engine shall remove all MEKs from | Yes       |
|      | the encryption engine on a power cycle or during |           |
|      | zeroization of the storage device.               |           |
+------+--------------------------------------------------+-----------+
| 5    | The SEK shall only be programmed once the HEK is | Yes       |
|      | available, and the HEK shall only be zeroized    |           |
|      | once the SEK is zeroized.                        |           |
+------+--------------------------------------------------+-----------+
| 6    | MEKs shall not be programmed while the SEK is    | Yes       |
|      | zeroized.                                        |           |
+------+--------------------------------------------------+-----------+

## Repository location

See <https://github.com/chipsalliance/Caliptra/tree/main/doc/ocp_lock>.

\beginappendices

# EAT format for attesting to the epoch key state {#sec:eat-format}

This section will be fleshed out with additional details as they become available.

# Sequence diagrams

## Sequence of events at boot

```plantuml {caption="UML: Power on" #fig:power-on-uml}
!include diagrams/uml/power_on.uml
```

## Sequence to obtain the current status of KMB

```plantuml {caption="UML: Get Status" #fig:get-status-uml}
!include diagrams/uml/get_status.uml
```

## Sequence to obtain the supported algorithms

```plantuml {caption="UML: Get Supported Algorithms" #fig:get-supported-algorithms-uml}
!include diagrams/uml/get_algorithms.uml
```

## Sequence to endorse an HPKE public key

```plantuml {caption="UML: Endorsing an HPKE public key" #fig:endorse-encapsulation-pub-key-uml}
!include diagrams/uml/endorse_encapsulation_pub_key.uml
```

## Sequence to rotate an HPKE keypair

```plantuml {caption="UML: Rotating a KEM Encapsulation Key" #fig:rotate-encapsulation-key-uml}
!include diagrams/uml/rotate_encapsulation_key.uml
```

## Sequence to generate an MPK

```plantuml {caption="UML: Generating an MPK" #fig:generate-mpk-uml}
!include diagrams/uml/generate_mpk.uml
```

## Sequence to ready an MPK

```plantuml {caption="UML: Readying an MPK" #fig:ready-mpk-uml}
!include diagrams/uml/ready_mpk.uml
```

## Sequence to rotate the access key of an MPK

```plantuml {caption="UML: Rewrapping an MPK" #fig:rewrap-mpk-uml}
!include diagrams/uml/rewrap_mpk.uml
```

## Sequence to mix an MPK into the MEK secret seed

```plantuml {caption="UML: Mixing an MPK" #fig:mix-mpk-uml}
!include diagrams/uml/mix_mpk.uml
```

## Sequence to load an MEK

```plantuml {caption="UML: Loading an MEK" #fig:load-mek-uml}
!include diagrams/uml/load_mek.uml
```

## Sequence to load MEK into the encryption engine key cache

```plantuml {caption="UML: Loading an MEK into the encryption engine key cache" #fig:load-mek-into-ee-uml}
!include diagrams/uml/load_mek_into_ee.uml
```

## Sequence to unload an MEK from the encryption engine key cache

```plantuml {caption="UML: Unloading an MEK" #fig:unload-mek-uml}
!include diagrams/uml/unload_mek.uml
```

## Sequence to unload all MEKs (i.e., zeroize) from the encryption engine key cache

```plantuml {caption="UML: Unloading all MEKs" #fig:clear-key-cache-uml}
!include diagrams/uml/clear_key_cache.uml
```
